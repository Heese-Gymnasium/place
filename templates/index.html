<!DOCTYPE html>
<html lang="de">
<head>
    <!--
    Pixel Canvas - Frontend Template
    
    Diese HTML-Datei enth√§lt die Benutzeroberfl√§che f√ºr die interaktive
    Pixel-Canvas-Anwendung. Sie verwendet HTML5 Canvas f√ºr die Darstellung
    und regelm√§√üiges Polling f√ºr Updates (kompatibel ohne externe Bibliotheken).
    
    Hauptkomponenten:
    - HTML5 Canvas Element f√ºr die Pixel-Darstellung
    - Farbauswahl-Dialog (Color Picker)
    - JavaScript f√ºr Canvas-Interaktion und Server-Kommunikation
    -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Canvas - Interaktives Zeichenprogramm</title>
    
    <style>
        /* ================================================================
           GRUNDLEGENDE STILE
           ================================================================ */
        
        /* Entfernt Standard-Abst√§nde und zentriert Inhalt */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            /* Dunkler Hintergrund f√ºr besseren Kontrast */
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            
            /* Flexbox f√ºr zentrierte Anordnung */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            
            /* Schriftart und Textfarbe */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ffffff;
        }
        
        /* ================================================================
           HEADER-BEREICH
           ================================================================ */
        
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            /* Farbverlauf im Text */
            background: linear-gradient(90deg, #e94560, #f39c12, #1abc9c);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            font-size: 1rem;
            color: #8892b0;
        }
        
        /* ================================================================
           TOOLBAR / WERKZEUGLEISTE
           ================================================================ */
        
        .toolbar {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .toolbar-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toolbar-item label {
            font-weight: 500;
        }
        
        /* Farbauswahl-Element (Color Picker) */
        #color-picker {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            /* Entfernt Standard-Styling des Browsers */
            -webkit-appearance: none;
            padding: 0;
        }
        
        /* Entfernt den inneren Rahmen bei Webkit-Browsern */
        #color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        
        #color-picker::-webkit-color-swatch {
            border: 2px solid #fff;
            border-radius: 6px;
        }
        
        /* Vorschau der aktuell ausgew√§hlten Farbe */
        .color-preview {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid #fff;
            background-color: #000000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        /* Status-Anzeige (Verbunden/Getrennt) */
        .status {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #e74c3c;
            /* Pulsierender Effekt f√ºr "verbunden" Status */
            animation: pulse 2s infinite;
        }
        
        .status-indicator.connected {
            background-color: #2ecc71;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* ================================================================
           CANVAS-CONTAINER
           ================================================================ */
        
        .canvas-container {
            /* Schatten und Rahmen f√ºr 3D-Effekt */
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            
            /* Rahmen um die Canvas */
            border: 3px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Die eigentliche HTML5 Canvas */
        #pixel-canvas {
            display: block;
            /* Deaktiviert Bildgl√§ttung f√ºr scharfe Pixel */
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            cursor: crosshair;
        }
        
        /* ================================================================
           INFORMATIONSBEREICH
           ================================================================ */
        
        .info-panel {
            margin-top: 20px;
            padding: 15px 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            text-align: center;
        }
        
        .coordinates {
            font-family: monospace;
            font-size: 1.1rem;
        }
        
        /* ================================================================
           FOOTER
           ================================================================ */
        
        footer {
            margin-top: 30px;
            font-size: 0.9rem;
            color: #8892b0;
        }
    </style>
</head>
<body>
    <!-- Header mit Titel -->
    <header>
        <h1>üé® Pixel Canvas</h1>
        <p class="subtitle">Klicke zum Malen | Scroll zum Zoomen | Rechts-Drag zum Verschieben</p>
    </header>
    
    <!-- Werkzeugleiste mit Farbauswahl und Status -->
    <div class="toolbar">
    <div class="toolbar-item">
            <label for="color-picker">Farbe:</label>
            <!-- HTML5 Color Picker f√ºr Farbauswahl -->
            <input type="color" id="color-picker" value="#e94560" title="Farbe ausw√§hlen">
            <div class="color-preview" id="color-preview"></div>
        </div>
        
        <div class="toolbar-item status">
            <span class="status-indicator" id="status-indicator"></span>
            <span id="status-text">Verbinde...</span>
        </div>
    </div>
    
    <!-- Canvas-Container -->
    <div class="canvas-container">
        <!-- HTML5 Canvas - Gr√∂√üe wird per JavaScript gesetzt -->
        <canvas id="pixel-canvas"></canvas>
    </div>
    
    <!-- Informationsbereich f√ºr Koordinaten -->
    <div class="info-panel">
        <p class="coordinates">
            Position: <span id="coord-display">--, --</span> | 
            Canvas-Gr√∂√üe: {{ width }} √ó {{ height }} Pixel
        </p>
    </div>
    
    <!-- Footer -->
    <footer>
        <p>Pixel Canvas - Echtzeit-Kollaboration</p>
    </footer>
    
    <script>
        /**
         * ================================================================
         * PIXEL CANVAS - CLIENTSEITIGES JAVASCRIPT
         * ================================================================
         * 
         * Dieses Script verwaltet:
         * - Die Canvas-Darstellung und Pixel-Rendering
         * - Benutzerinteraktionen (Klicks, Mausbewegungen)
         * - Server-Kommunikation √ºber HTTP-Anfragen
         * - Regelm√§√üige Updates durch Polling
         */
        
        // ================================================================
        // KONSTANTEN UND KONFIGURATION
        // ================================================================
        
        // Canvas-Dimensionen vom Server (√ºber Flask Template)
        const CANVAS_WIDTH = {{ width }};
        const CANVAS_HEIGHT = {{ height }};
        
        // Gr√∂√üe eines einzelnen Pixels auf dem Bildschirm (in CSS-Pixeln)
        // Erh√∂ht die Sichtbarkeit der einzelnen Pixel
        const PIXEL_SIZE = 10;
        
        // Polling-Intervall in Millisekunden f√ºr regelm√§√üige Updates
        const POLL_INTERVAL = 200;
        
        // ================================================================
        // DOM-ELEMENTE REFERENZIEREN
        // ================================================================
        
        // Canvas und 2D-Kontext f√ºr Zeichenoperationen
        const canvas = document.getElementById('pixel-canvas');
        const ctx = canvas.getContext('2d');
        
        // UI-Elemente
        const colorPicker = document.getElementById('color-picker');
        const colorPreview = document.getElementById('color-preview');
        const statusIndicator = document.getElementById('status-indicator');
        const statusText = document.getElementById('status-text');
        const coordDisplay = document.getElementById('coord-display');
        
        // Speichert den aktuellen lokalen Zustand der Pixel
        let localPixelData = null;
        
        // ================================================================
        // ZOOM UND PAN VERWALTUNG
        // ================================================================
        
        // Field of View - definiert welcher Bereich der Pixel-Art sichtbar ist
        let fieldOfView = {
            x1: 0,                  // Linke Kante
            y1: 0,                  // Obere Kante
            x2: CANVAS_WIDTH,       // Rechte Kante
            y2: CANVAS_HEIGHT       // Untere Kante
        };
        
        // Zoom-Faktor und Pan-Tracking
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let panStartFOV = { x1: 0, y1: 0, x2: CANVAS_WIDTH, y2: CANVAS_HEIGHT };
        
        // ================================================================
        // CANVAS INITIALISIERUNG
        // ================================================================
        
        /**
         * Initialisiert die Canvas-Gr√∂√üe basierend auf den Pixel-Dimensionen.
         * Die Canvas wird gr√∂√üer als die logischen Pixel dargestellt,
         * um bessere Sichtbarkeit zu gew√§hrleisten.
         */
        function initCanvas() {
            // Canvas-Gr√∂√üe in tats√§chlichen Bildschirm-Pixeln setzen
            canvas.width = CANVAS_WIDTH * PIXEL_SIZE;
            canvas.height = CANVAS_HEIGHT * PIXEL_SIZE;
            
            // Bildgl√§ttung deaktivieren f√ºr scharfe Pixel-Kanten
            ctx.imageSmoothingEnabled = false;
            
            // Canvas mit Wei√ü f√ºllen (Standard-Hintergrund)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            console.log(`[INIT] Canvas: ${canvas.width}x${canvas.height}px (${CANVAS_WIDTH}x${CANVAS_HEIGHT} art pixels)`);
        }
        
        // ================================================================
        // PIXEL-RENDERING FUNKTIONEN
        // ================================================================
        
        
        // ================================================================
        // SHADER / MAPPING FUNCTION
        // ================================================================
        
        /**
         * YOUR CUSTOM SHADER FUNCTION
         * 
         * Diese Funktion wird f√ºr jeden Pixel aus der Pixel-Art aufgerufen.
         * Sie bestimmt, wie dieser Pixel gerendert wird.
         * 
         * BEISPIELE:
         * 
         * 1. Einfach: Gib die normale Farbe zur√ºck
         *    return pixelData[artY][artX];
         * 
         * 2. Checkerboard: Alterniere zwischen zwei Farben
         *    if ((artX + artY) % 2 === 0) return "#000000";
         *    return pixelData[artY][artX];
         * 
         * 3. Alle Pixel gr√ºn:
         *    return "#00FF00";
         * 
         * @param {number} artX - X-Koordinate in der Pixel-Art (0-49)
         * @param {number} artY - Y-Koordinate in der Pixel-Art (0-49)
         * @param {Array<Array<string>>} pixelData - Die gesamte Pixel-Art Datenstruktur
         * @returns {string} - Farbe im Hex-Format (#RRGGBB)
         */
        function customShader(artX, artY, pixelData) {
            // Gib die tats√§chliche Farbe des Pixels zur√ºck
            return pixelData[Math.floor(artY)][artX];
        }
        
        // ================================================================
        // INVERSE SHADER - F√ºr Mouse-Koordinaten
        // ================================================================
        
        /**
         * Inverse Shader-Funktion: Konvertiert Screen-Pixel in Pixel-Art-Koordinaten
         * unter Ber√ºcksichtigung des aktuellen Fensters.
         * 
         * @param {number} screenX - X-Koordinate auf dem Screen
         * @param {number} screenY - Y-Koordinate auf dem Screen
         * @param {number} screenWidth - Breite des Bildschirms in Pixeln
         * @param {number} screenHeight - H√∂he des Bildschirms in Pixeln
         * @returns {Object} {x: number, y: number} - Koordinaten in der Pixel-Art
         */
        function inverseShader(screenX, screenY, screenWidth, screenHeight) {
            const windowWidth = fieldOfView.x2 - fieldOfView.x1;
            const windowHeight = fieldOfView.y2 - fieldOfView.y1;
            
            // Inverse Formel:
            // artPixel[i, j] = int(screenPixel[x, y] / screenSize * (x2-x1)) + x1
            const artX = Math.floor((screenX / screenWidth) * windowWidth) + fieldOfView.x1;
            const artY = Math.floor((screenY / screenHeight) * windowHeight) + fieldOfView.y1;
            
            return { x: artX, y: artY };
        }
        
        /**
         * Rendert die gesamte Canvas basierend auf den empfangenen Pixel-Daten
         * und ruft f√ºr jeden Pixel den customShader auf.
         * Respektiert das aktuelle Field of View f√ºr Zoom und Pan.
         * 
         * @param {Array<Array<string>>} pixelData - 2D-Array mit Farbwerten
         */
        function renderFullCanvas(pixelData) {
            // Berechne die Gr√∂√üe des sichtbaren Bereichs (FOV)
            const fovWidth = fieldOfView.x2 - fieldOfView.x1;
            const fovHeight = fieldOfView.y2 - fieldOfView.y1;
            
            // Berechne die Gr√∂√üe eines Pixel-Art-Pixels auf dem Screen
            const screenPixelWidth = canvas.width / fovWidth;
            const screenPixelHeight = canvas.height / fovHeight;
            
            // Nur Pixel rendern, die im FOV sichtbar sind
            const startX = Math.floor(fieldOfView.x1);
            const endX = Math.ceil(fieldOfView.x2);
            const startY = Math.floor(fieldOfView.y1);
            const endY = Math.ceil(fieldOfView.y2);
            
            // Durch alle sichtbaren Pixel iterieren
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    // Nur rendern wenn Koordinaten g√ºltig sind
                    if (x >= 0 && x < pixelData[0].length && y >= 0 && y < pixelData.length) {
                        // Rufe customShader auf f√ºr diesen Pixel
                        const color = customShader(x, y, pixelData);
                        
                        // Berechne die Position auf dem Screen (relative zum FOV)
                        const screenX = (x - fieldOfView.x1) * screenPixelWidth;
                        const screenY = (y - fieldOfView.y1) * screenPixelHeight;
                        
                        // Zeichne den Pixel mit der berechneten Gr√∂√üe
                        ctx.fillStyle = color;
                        ctx.fillRect(
                            screenX,                // X-Position auf dem Screen
                            screenY,                // Y-Position auf dem Screen
                            screenPixelWidth,       // Breite des Pixels (skaliert mit Zoom)
                            screenPixelHeight       // H√∂he des Pixels (skaliert mit Zoom)
                        );
                    }
                }
            }
        }
        
        /**
         * Konvertiert Hex-Farbe zu RGB
         */
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 255, b: 255 };
        }
        
        /**
         * Aktualisiert nur ge√§nderte Pixel (effizienter als vollst√§ndiges Neurendern).
         * 
         * @param {Array<Array<string>>} newData - Neue Pixel-Daten vom Server
         */
        function updateChangedPixels(newData) {
            if (!localPixelData) {
                renderFullCanvas(newData);
                localPixelData = JSON.parse(JSON.stringify(newData));
                return;
            }
            
            // Einfach alles neurendern - mehr Sicherheit
            renderFullCanvas(newData);
            localPixelData = JSON.parse(JSON.stringify(newData));
        }
        
        // ================================================================
        // SERVER-KOMMUNIKATION
        // ================================================================
        
        /**
         * L√§dt die aktuellen Canvas-Daten vom Server.
         * Verwendet fetch API f√ºr asynchrone HTTP-Anfragen.
         */
        async function loadCanvasData() {
            try {
                const response = await fetch('/api/canvas');
                if (response.ok) {
                    const data = await response.json();
                    updateChangedPixels(data.pixels);
                    
                    // Status auf "Verbunden" setzen
                    statusIndicator.classList.add('connected');
                    statusText.textContent = 'Verbunden';
                }
            } catch (error) {
                console.error('[FEHLER] Konnte Canvas-Daten nicht laden:', error);
                statusIndicator.classList.remove('connected');
                statusText.textContent = 'Getrennt';
            }
        }
        
        /**
         * Sendet eine Pixel-√Ñnderung an den Server.
         * 
         * @param {number} x - X-Koordinate des Pixels
         * @param {number} y - Y-Koordinate des Pixels
         * @param {string} color - Neue Farbe im Hex-Format
         */
        async function sendPixelUpdate(x, y, color) {
            try {
                const response = await fetch('/api/pixel', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ x, y, color })
                });
                
                if (response.ok) {
                    // Lokal sofort aktualisieren f√ºr schnelle Reaktion
                    if (localPixelData) {
                        localPixelData[y][x] = color;
                    }
                    console.log(`[PIXEL] Aktualisiert: (${x}, ${y}) -> ${color}`);
                }
            } catch (error) {
                console.error('[FEHLER] Konnte Pixel nicht aktualisieren:', error);
            }
        }
        
        /**
         * Startet das regelm√§√üige Polling f√ºr Updates.
         * Holt in festgelegten Intervallen den aktuellen Zustand vom Server.
         */
        function startPolling() {
            // Initiales Laden der Canvas-Daten
            loadCanvasData();
            
            // Regelm√§√üiges Polling starten
            setInterval(loadCanvasData, POLL_INTERVAL);
            console.log(`[INFO] Polling gestartet (Intervall: ${POLL_INTERVAL}ms)`);
        }
        
        // ================================================================
        // BENUTZERINTERAKTIONEN
        // ================================================================
        
        /**
         * Konvertiert Canvas-Koordinaten (Bildschirm-Pixel) in 
         * Pixel-Art-Koordinaten unter Ber√ºcksichtigung des aktuellen Zooms und Pan.
         * 
         * @param {MouseEvent} event - Maus-Event mit Koordinaten
         * @returns {Object} - Objekt mit x und y Koordinaten in der Pixel-Art
         */
        function getPixelCoordinates(event) {
            // Canvas-Position relativ zum Viewport ermitteln
            const rect = canvas.getBoundingClientRect();
            
            // Mausposition relativ zur Canvas berechnen
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;
            
            // Konvertiere Screen-Koordinaten zu Pixel-Art-Koordinaten
            const artCoords = inverseShader(screenX, screenY, canvas.width, canvas.height);
            
            return artCoords;
        }
        
        /**
         * Maus-Rad Event - Zoom in/out
         * Scroll down = Zoom in (increment x1/y1, decrement x2/y2)
         * Scroll up = Zoom out (decrement x1/y1, increment x2/y2)
         */
        canvas.addEventListener('wheel', function(event) {
            event.preventDefault();
            
            // Zoom-Faktor basierend auf Scroll-Richtung
            // Scroll down (deltaY > 0) = Zoom in (smaller FOV) = zoom factor > 1
            // Scroll up (deltaY < 0) = Zoom out (larger FOV) = zoom factor < 1
            const zoomFactor = event.deltaY > 0 ? 0.8 : 1.2;
            
            // Mausposition auf Canvas
            const rect = canvas.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;
            
            // Pixel-Art-Koordinaten unter Maus vor dem Zoom
            const artCoordsBefore = inverseShader(screenX, screenY, canvas.width, canvas.height);
            
            // Berechne neue Field of View mit Zoom
            const currentFovWidth = fieldOfView.x2 - fieldOfView.x1;
            const currentFovHeight = fieldOfView.y2 - fieldOfView.y1;
            
            const newFovWidth = currentFovWidth * zoomFactor;
            const newFovHeight = currentFovHeight * zoomFactor;
            
            // Begrenzte Zoom-Grenzen (mindestens 1 Pixel, maximal volle Gr√∂√üe)
            const boundedFovWidth = Math.max(1, Math.min(CANVAS_WIDTH, newFovWidth));
            const boundedFovHeight = Math.max(1, Math.min(CANVAS_HEIGHT, newFovHeight));
            
            // Zentrum des Zooms ist die Mausposition
            const fovCenterX = artCoordsBefore.x;
            const fovCenterY = artCoordsBefore.y;
            
            // Neue Grenzen berechnen (zentriert auf Mausposition)
            let newX1 = fovCenterX - (boundedFovWidth / 2);
            let newY1 = fovCenterY - (boundedFovHeight / 2);
            
            // Bounds clamping
            newX1 = Math.max(0, Math.min(CANVAS_WIDTH - boundedFovWidth, newX1));
            newY1 = Math.max(0, Math.min(CANVAS_HEIGHT - boundedFovHeight, newY1));
            
            fieldOfView.x1 = newX1;
            fieldOfView.y1 = newY1;
            fieldOfView.x2 = newX1 + boundedFovWidth;
            fieldOfView.y2 = newY1 + boundedFovHeight;
            
            // Canvas neu rendern mit neuem Zoom
            if (localPixelData) {
                renderFullCanvas(localPixelData);
            }
            
            console.log(`[ZOOM] FOV: (${fieldOfView.x1.toFixed(1)}, ${fieldOfView.y1.toFixed(1)}) - (${fieldOfView.x2.toFixed(1)}, ${fieldOfView.y2.toFixed(1)})`);
        });
        
        /**
         * Mouse Down - Starte Panning
         */
        canvas.addEventListener('mousedown', function(event) {
            if (event.button === 2 || event.button === 1) { // Rechtsklick oder Mittelklick
                isPanning = true;
                panStartX = event.clientX;
                panStartY = event.clientY;
                panStartFOV = JSON.parse(JSON.stringify(fieldOfView));
                event.preventDefault();
            }
        });
        
        /**
         * Context Menu - Deaktiviere Rechtsklick-Popup auf der Canvas
         */
        canvas.addEventListener('contextmenu', function(event) {
            event.preventDefault();
        });
        
        /**
         * Mouse Move - Pan die Canvas
         */
        document.addEventListener('mousemove', function(event) {
            if (!isPanning) return;
            
            // Berechne wie viel die Maus sich bewegt hat
            const deltaX = event.clientX - panStartX;
            const deltaY = event.clientY - panStartY;
            
            // Konvertiere Pixel-Bewegung in Pixel-Art-Bewegung
            const fovWidth = fieldOfView.x2 - fieldOfView.x1;
            const fovHeight = fieldOfView.y2 - fieldOfView.y1;
            
            const pixelSize = canvas.width / fovWidth;
            const artDeltaX = deltaX / pixelSize;
            const artDeltaY = deltaY / pixelSize;
            
            // Neue Field of View mit Pan
            fieldOfView.x1 = Math.max(0, Math.min(CANVAS_WIDTH - fovWidth, panStartFOV.x1 - artDeltaX));
            fieldOfView.y1 = Math.max(0, Math.min(CANVAS_HEIGHT - fovHeight, panStartFOV.y1 - artDeltaY));
            fieldOfView.x2 = fieldOfView.x1 + fovWidth;
            fieldOfView.y2 = fieldOfView.y1 + fovHeight;
            
            // Canvas neu rendern mit neuem Pan
            if (localPixelData) {
                renderFullCanvas(localPixelData);
            }
        });
        
        /**
         * Mouse Up - Beende Panning
         */
        document.addEventListener('mouseup', function() {
            isPanning = false;
        });
        
        /**
         * Klick-Handler f√ºr die Canvas.
         * √ñffnet einen Farbw√§hler-Popup und sendet dann die Pixel-Aktualisierung.
         */
        canvas.addEventListener('click', function(event) {
            const coords = getPixelCoordinates(event);
            
            // Sicherstellen, dass Koordinaten innerhalb der Grenzen liegen
            if (coords.x >= 0 && coords.x < CANVAS_WIDTH && 
                coords.y >= 0 && coords.y < CANVAS_HEIGHT) {
                
                // Erstelle einen versteckten Input f√ºr den Farbw√§hler
                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.id = 'temp-color-picker';
                colorInput.value = colorPicker.value;
                colorInput.title = 'Farbe ausw√§hlen';
                
                // Zeige den Farbw√§hler an und warte auf Auswahl
                colorInput.click();
                
                // Wenn der Benutzer eine Farbe ausgew√§hlt hat
                colorInput.addEventListener('change', function(colorEvent) {
                    const selectedColor = colorInput.value;
                    
                    // Pixel-Update an Server senden mit ausgew√§hlter Farbe
                    sendPixelUpdate(coords.x, coords.y, selectedColor);
                    
                    // Aktualisiere auch den Haupt-Farbw√§hler auf die neue Farbe
                    colorPicker.value = selectedColor;
                    colorPreview.style.backgroundColor = selectedColor;
                });
                
                // Entferne den tempor√§ren Input-Element nach kurzer Zeit
                setTimeout(function() {
                    colorInput.remove();
                }, 1000);
            }
        });
        
        /**
         * Mausbewegung √ºber der Canvas.
         * Aktualisiert die Koordinaten-Anzeige.
         */
        canvas.addEventListener('mousemove', function(event) {
            if (!isPanning) {  // Nur koordinaten anzeigen wenn nicht panning
                const coords = getPixelCoordinates(event);
                
                // Koordinaten in der Anzeige aktualisieren
                if (coords.x >= 0 && coords.x < CANVAS_WIDTH && 
                    coords.y >= 0 && coords.y < CANVAS_HEIGHT) {
                    coordDisplay.textContent = `${coords.x}, ${coords.y}`;
                } else {
                    coordDisplay.textContent = '--, --';
                }
            }
        });
        
        /**
         * Maus verl√§sst die Canvas.
         * Setzt die Koordinaten-Anzeige zur√ºck.
         */
        canvas.addEventListener('mouseleave', function() {
            coordDisplay.textContent = '--, --';
        });
        
        // ================================================================
        // FARBAUSWAHL-FUNKTIONEN
        // ================================================================
        
        /**
         * Aktualisiert die Farb-Vorschau bei √Ñnderung des Color Pickers.
         */
        colorPicker.addEventListener('input', function() {
            colorPreview.style.backgroundColor = colorPicker.value;
        });
        
        // Initiale Farb-Vorschau setzen
        colorPreview.style.backgroundColor = colorPicker.value;
        
        // ================================================================
        // ANWENDUNG STARTEN
        // ================================================================
        
        // Canvas initialisieren wenn Seite geladen ist
        initCanvas();
        
        // Polling f√ºr Updates starten
        startPolling();
        
        console.log('[INFO] Pixel Canvas Anwendung gestartet');
    </script>
</body>
</html>
